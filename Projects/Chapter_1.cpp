
#include <clocale>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <ostream>

 using namespace std;

void OutputInConsole(){
    cout << "Output in console:" << endl;

    cout << "English: " << "Hello World!" << endl;
    setlocale(LC_ALL, "ru"); //#include <clocale>
    cout << "Русский: " << "Привет мир!" << endl;

    cout << endl;
}

void Variables(){
    cout << "Variables types:" << endl;

    int age;
    int Age;
    int _age;

    int INT1 {123 + 123}, INT2 = 456 + 214, INT3 (789 / 12);

    //Нотация присваивания
    int Int;
    Int = 20;
    cout << "Int = " << Int << endl;

    //Инициализация в фигурных скобках 
    int FigureBracket {100};
    cout << "Figure Bracket = {" << FigureBracket << "}" << endl;

    //Функциональная нотация
    int Bracket (777);
    cout << "Bracket = (" << Bracket << ")" << endl;

    //Инициализация нулем
    int NullInt {};
    cout << "Null Int = {" << NullInt << "}" << endl;

    //Изменение значения
    int obj1 = 777;
    cout << "Object 1 = " << obj1 << endl;
    obj1 = 12345;
    cout << "Object 1 = " << obj1 << endl;

    cout << endl;
}

void DataTypes(){
    cout << "Data types:" << endl;

    //Логический тип////////////////////////////////////////////////////////////////////////
    bool isTrue {true};
    bool isFalse = false;
    bool DefaulBool; //false

    cout << "IsTrue = {" << isTrue << "}" << endl;
    cout << "IsFalse = " <<  isFalse << endl;
    cout << "Default Bool Value = " <<  DefaulBool << endl;

    //Целочисленные типы///////////////////////////////////////////////////////////////////////

    signed char schar = -127;//представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от -128 до 127

    unsigned char unschar = 255; //представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255

    char CHAR = 0; //Представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255
    /*
    Несмотря на то, что данный тип представляет тот же диапазон значений, что и вышеописанный тип signed char, но они не эквивалентны. 
    Тип char предназначен для хранения числового кода символа и в реальности может представлять как signed byte, так и unsigned byte в зависимости от конкретного компилятора.
    */

    short Short = -32768; //представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит).
    unsigned short UnShort = 65535; //представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит).

    int INT {-2147483648}; /*
               представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). 
               Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах).
                Но в любом случае размер должен быть больше или равен размеру типа short и меньше или равен размеру типа long 
            */
    cout << "INT = " <<  INT << endl;
    
    unsigned int unInt {4294967295}; /*
                            представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита),
                            и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт).
                          */
    cout << "Unsigned int = " <<  unInt << endl;

    long LONG {-2147483648}; /*
                            В зависимости от архитектуры может занимать 4 или 8 байт и представляет целое число в диапазоне от −2 147 483 648 до 2 147 483 647 (при 4 байтах)
                             или от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807 (при 8 байтах). Занимает в памяти 4 байта (32 бита) или.
                             */
    cout << "Long = " <<  LONG << endl;

    unsigned long UnLONG {4294967295}; //представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита).
    cout << "Unsigned Long = " <<  UnLONG << endl;

    long long LONG_LONG = -922337203685477580; //представляет целое число в диапазоне от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти 8 байт (64 бита).
    cout << "Long Long = " <<  LONG_LONG << endl;

    unsigned long long UnLONG_LONG = 1844674407370955165; //представляет целое число в диапазоне от 0 до 1 844 674 407 370 955 165. Занимает в памяти 8 байт (64 бита).
    cout << "Unsigned Long Long = " <<  UnLONG_LONG << endl;

    int num{ 1'234'567'890 };
    cout << "num = " << num << "\n";   // num = 1234567890

    //Различные системы исчисления///////////////////////////////////////////////////////////////////////

    //16-ричная
    int num1{ 0x1A};        // 26 - в десятичной
    int num2{ 0xFF };       // 255 - в десятичной
    int num3{ 0xFFFFFF };   //16777215 - в десятичной

    //8-ричная
    int num4{ 034};        // 26 - в десятичной
    int num5{ 0377 };       // 255 - в десятичной

    //2-чная (бинарная) 
    int num6{ 0b11010};         // 26 - в десятичной
    int num7{ 0b11111111 };     // 255 - в десятичной

    //Числа с плавающей точкой///////////////////////////////////////////////////////////////////////

    /*
    Число с плавающей точкой состоит из двух частей: мантиссы и показателя степени. Оба могут быть как положительными, так и отрицательными. 
    Величина числа – это мантисса, умноженная на десять в степени экспоненты.
    Например, число 365 может быть записано в виде числа с плавающей точкой следующим образом:
    3.650000E02

    В качестве разделителя целой и дробной частей используется символ точки. Мантисса здесь имеет семь десятичных цифр - 3.650000, показатель степени - две цифры 02. 
    Буква E означает экспоненту, после нее указывается показатель степени (степени десяти), на которую умножается часть 3.650000 (мантисса), чтобы получить требуемое значение.
    То есть, чтобы вернуться к обычному десятичному представлению, нужно выполнить следующую операцию:
    3.650000 × 10^2 = 365

    Другой пример - возьмем небольшое число:
    -3.650000E-03
    В данном случае мы имеем дело с числом –3.65 × 10-3, что равно –0.00365. Здесь мы видим, что в зависимости от значения показателя степени десятичная точка "плавает". 
    Собственно поэтому их и называют числами с плавающей точкой.
    */

    //Даже если переменной присваивается целое число, чтобы показать, что мы присваиваем число с плавающей точкой, применяется точка
    double INT_DOUBLE {10.0}; //представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)
    double D_DOUBLE {123453.54345};

    // Чтобы показать, что число представляет другой тип, для float применяется суффикс f/F, а для long double - l/L
    float FLOAT {5.0f};//представляет вещественное число одинарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)
    long double LONG_DOUBLE {234634.42356546l};//представляет вещественное число двойной точности с плавающей точкой не менее 8 байт (64 бит). 
                                               //В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.

    float f_num{-100000000000000000000000000000000000000.0f / 3.0f};
    double d_num{-100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 / 3.0};
    long double l_d_num{10.0l / 3.0l};

    cout << setprecision(100) << f_num << endl; // вывод с максимальной точностью до 38 цифр. Требуется подключение <iomanip>
    cout << setprecision(1000) << d_num << endl; // вывод с максимальной точностью до 308 цифр. Требуется подключение <iomanip>
    cout << setprecision(1000) << l_d_num << endl; // вывод максимальной с точностью. Требуется подключение <iomanip>

    //Размеры типов данных///////////////////////////////////////////////////////////////////////

    /*
    Однако бывают ситуации, когда необходимо точно знать размер определенного типа. 
    И для этого в С++ есть оператор sizeof(), который возвращает размер памяти в байтах, которую занимает переменная.
    */
    long double LongDouble {6968956.275459845674362356544l};
    cout << "Size LongDouble = " << sizeof(LongDouble) << endl;

    //Символьные типы///////////////////////////////////////////////////////////////////////

    char IsChar {34}; //представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255
    wchar_t IsWCHAR {L'w'};//представляет расширенный символ. На Windows занимает в памяти 2 байта (16 бит), на Linux - 4 байта (32 бита). 
                            //Может хранить любой значение из диапазона от 0 до 65 535 (при 2 байтах), либо от 0 до 4 294 967 295 (для 4 байт)
    char16_t IsChar16t {u'L'};//представляет один символ в кодировке Unicode. Занимает в памяти 2 байта (16 бит). Может хранить любой значение из диапазона от 0 до 65 535
    char32_t IsChar32t {U'S'};//представляет один символ в кодировке Unicode. Занимает в памяти 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 4 294 967 295
    //wcout << "CHAR = " << IsChar << "\nCHAR16_T = " << IsChar16t << "\nCHAR32_T = " << IsChar32t << endl; 

    //Спецификатор auto///////////////////////////////////////////////////////////////////////

    /*
    Спецификатор auto следует использовать в неопределённых ситуациях, когда явно определить тип переменной затруднительно.
    Auto практически не влияет на производительность кода, так что его использование никак не замедлит код.
    При явном определении типов переменных следует использовать явные типы данных - это более читаемо.
    */

    auto number = 5;        // number имеет тип int
    auto sum {1234.56};    // sum имеет тип double
    auto distance {267UL};  // distance имеет тип unsigned long

    auto InputData(0);
    cout << "Input Auto Data: ";
    cin >> InputData;

    cout <<"Auto Int = "<< number <<"\nAuto Double = "<< sum <<"\nAuto Unsigned Long = "<< distance<<"\nAuto Input = "<< InputData << endl;

    cout << endl;
}

void Constants(){
    cout << "Constants:" << endl;

    //Константы следует именовать с больших букв (CONST_VARIABLE = 100)
    const int n {22};

    int a {10};
    const int b {7};
    const int d {b};
    const int x {a};

    cout << "Constants: " << n << ", " << b << ", " << d << ", " << x << endl;

    cout << endl;
}

void InputOutput(){
    cout << "Input and Output in console:" << endl;

    short age {33};
    double weight {81.23};

    cout << "Name: " << "Tom" << "\n"; // необходимо подключить библиотеку iostream
    cout << "Age: " << age << endl; // необходимо подключить библиотеку iostream
    cout << "Weight: " << weight << endl; //  необходимо подключить библиотеку iostream

    int age2;
    double weight2;
    cout << "Input age: ";
    cin >> age2;// необходимо подключить библиотеку iostream
    cout << "Input weight: ";
    cin >> weight2;// необходимо подключить библиотеку iostream
    cout << "Age2: " << age2 << "\t Weight2: " << weight2 << endl;

    cout << endl;
}

void NamespaceUsing(){
    cout << "Using namespaces and pseudonyms:" << endl;

    /*
    При чтении и записи в предыдущих темах использовались объекты cout и cin соответственно. Причем они использовались с префиксом . 
    Этот префикс указывает, что объекты cout, cin, endl определены в пространстве имен std. 
    А само двойное двоеточие :: представляет оператор области видимости (scope operator), который позволяет указать, в каком пространстве имен определен объект. 
    И без префикса эти объекты по умолчанию мы использовать не можем.
    */
    using std::cout;
    using std::endl;
    cout << ":: = SCOPE OPERATOR" << endl;

    //Определение псевдонимов///////////////////////////////////////////////////////////////////////

    /*
    Ключевое слово using также позволяет определять псевдонимы для типов.
    Это может пригодиться, когда мы работаем с типами с длинными названиями, а определение коротких псевдонимов позволит сократить код.
    */
    using ull = unsigned long long;

    ull ULL = {23522354234};
    cout << "Unsigned Long Long is \"ull\" = " << ULL << endl;

    cout << endl;
}

void ArithmeticOperations(){
    cout << "Arithmetic Operations:" << endl;

    //Арифметические операции///////////////////////////////////////////////////////////////////////////////////////////////////////

    short AplusB {10+40};
    cout << "Plus: " << "10 + 40 = " << AplusB << endl;

    short AminusB = 100-77;
    cout << "Minus: " << "100 - 77 = " << AminusB << endl;
    
    short AmultiplicationB (4*16);
    cout << "Multiplication: " << "4 * 16 = " << AmultiplicationB << endl;

    short AdivisionB = {300/200};
    cout << "Division: " << "300 / 200 = " << AdivisionB << endl;

    float Adivision_floatB = {300.0f /65.0f};
    cout << "Division float: " << "300.0f / 65.0f = " << Adivision_floatB << endl;

    short AremainderB = {300%75};
    cout << "Remainder: " << "300 % 75 = " << AremainderB << endl;

    //Некоторые особенности при работе с числами с плавающей точкой///////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    При сложении или вычитании чисел с плавающей точкой, которые сильно отличаются по значению, следует проявлять осторожность. 
    Например, сложим число 1.23E-4 (0.000123) и 3.65E+6 (3650000). Мы ожидаем, что сумма будет равна 3650000,000123. 
    Но при преобразовании в число с плавающей запятой с точностью до семи цифр это становится следующим
    */
    float num1{ 1.23E-4  };        // 0.000123
    float num2{ 3.65E+6  };        // 3650000
    float sum {num1 + num2};       // sum = 3.65e+06
    cout << "sum =" << sum << "\n";

    /*
    Также стоит отметить, что стандарт IEEE, который реализуется компиляторами С++, определяет специальные значения для чисел с плавающей точкой,
    в которых мантисса на бинарном уровне состоит только из нулей, а экспонента, которая состоит из одних единиц,
    в зависимости от знака представляет значения +infinity (плюс бесконечность +∞) и -infinity (минус бесконечность -∞).
    И при делении положительного числа на ноль, результатом будет +infinity, а при делении отрицательного числа на ноль - -infinity.

    Другое специальное значение с плавающей точкой, определенное этим стандартом, представляет значение NaN (не число). 
    Это значение представляет результат операции, который не определяется математически, например, когда ноль делится на ноль или бесконечность на бесконечность. 
    Результатом любой операции, в которой один или оба операнда являются NaN, также является NaN.
    */
    double a{ 1.5 }, b{}, c{}, d {-1.5};
    double result { a / b };
    cout << a << "/" << b << " = " << result << endl; // +inf
    result = d / c;
    cout << d << "/" << c << " = " << result << endl; // -inf
    result = b / c;
    cout << b << "/" << c << " = " << result << endl; // NaN
    cout << result << " + " << a << " = " << result + a << endl; // NaN

    //Инкремент и декремент////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Также есть две унарные арифметические операции, которые производятся над одним числом: ++ (инкремент) и -- (декремент). 
    Каждая из операций имеет две разновидности: префиксная и постфиксная
    */

    //префиксный инкремент
    short exam {100};
    short prefix {++exam};
    cout << "exam = " << exam << endl;
    cout << "prefix = " << prefix << endl;

    //постфиксный инкремент
    exam = {100};
    prefix = {exam++};
    cout << "exam = " << exam << endl;
    cout << "prefix = " << prefix << endl;

    //префиксный декремент
    exam = {100};
    prefix = {--exam};
    cout << "exam = " << exam << endl;
    cout << "prefix = " << prefix << endl;

    //постфиксный декремент
    exam = {100};
    prefix = {exam--};
    cout << "exam = " << exam << endl;
    cout << "prefix = " << prefix << endl;

    //Приоритет и ассоциативность операторов/////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Операции в порядке уменьшения приоритета:
    () (Переопределение порядка)
    ++ (инкремент), -- (декремент)
    * (умножение), / (деление), % (остаток от деления)
    + (сложение), - (вычитание)
    */

    short number1 {8};
    short number2 {7};
    int number3 {(number1 + 5) * ++number2};      // number3 = 104
    cout << "number3 = " << number3 << endl;

    cout << endl;
}

void StaticTypingAndTypeConversions(){
    cout << "Static Typing And Type Conversions:" << endl;

    //Примеры неявных преобразований////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //Переменной типа bool присваивается значение другого типа. В этом случае переменная получает false, если значение равно 0.
    //Во всех остальных случаях переменная получает true.
    bool a = 1;     // true
    bool b = 0;     // false
    bool c = 'g'; // true
    bool d = 3.4;   // true

    //Числовой или символьной переменной присваивается значение типа bool. В этом случае переменная получает 1, если значение равно true,
    //либо получает 0, если присваиваемое значение равно false.
    int e = true;       // 1
    double f = false;   // 0

    //Целочисленной переменной присваивается дробное число. В этом случае дробная часть после запятой отбрасывается.
    int g = 3.4;        // 3
    int h = 3.6;        // 3

    //Переменной, которая представляет тип с плавающей точкой, присваивается целое число.
    //В этом случае, если целое число содержит больше битов, чем может вместить тип переменной, то часть информации усекается.
    float k = 35005;                // 35005
    double l = 3500500000033;       // 3.5005e+012

    /*
    Переменной беззнакового типа (unsigned) присваивается значение не из его диапазона. В этом случае результатом будет остаток от деления по модулю.
    Например, тип unsigned char может хранить значения от 0 до 255. Если присвоить ему значение вне этого диапазона,
    то компилятор присвоит ему остаток от деления по модулю 256 (так как тип unsigned char может хранить 256 значений).
    Так, при присвоении значения -5 переменная типа unsigned char получит значение 251
    */
    unsigned char m = -5;           // 251
    unsigned short n = -3500;       // 62036
    unsigned int o = -50000000;     // 4244967296

    //Преобразования в арифметических операциях//////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    В арифметических операциях необходимо, чтобы оба операнда представляли один и тот же тип. Если же операнды имеют разные типы,
    то компилятор автоматически выбирает операнд с типом который имеет меньший диапазон значений и пытается его преобразовать в тип второго операнда,
    который имеет больший диапазон значений. С точки зрения преобразований в операциях типы можно расположить следующим образом в порядке приоритета
    (от более высокого к более низкому):

    1) long double
    2) double
    3) float
    4) unsigned long long
    5) long long
    6) unsigned long
    7) long
    8) unsigned int
    9) int
    */

    //Опасные и безопасные преобразования//////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Те преобразования, при которых не происходит потеря информации, являются безопасными. Как правило, это преобразования от типа с меньшей разрядностью к типу с большей разрядностью.
    В частности, это следующие цепочки преобразований:

    1) bool -> char -> short -> int -> double -> long double
    2) bool -> char -> short -> int -> long -> long long
    3) unsigned char -> unsigned short -> unsigned int -> unsigned long
    4) float -> double -> long double
    */
    
    short p = 'g'; // преобразование из char в short
    int r = 10;
    double s = r; // преобразование из int в double
    float t = 3.4;
    double u = t; // преобразование из float в double
    double x = 35; // преобразование из int в double

    //Явные преобразования типов///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //Для выполнения явных преобразований типов (explicit type conversion) применяется оператор static_cast
    //static_cast<type>(value)

    /*
    Данный оператор преобразует значение в круглых скобках - value к типу, который указан в угловых скобках - type.
    Слово static в названии оператора отражает тот факт, что приведение проверяется статически, то есть во время компиляции.
    Применение оператора static_cast указывает компилятору, что мы уверены, что в этом месте надо применить преобразование, поэтому даже при инициализации в фигурных скобках компилятор не сгенерирует ошибку.
    Например, программист заработал за 8 часовой рабочий день 100,2$, рассчитаем его заработок за час, но в виде значения unsigned int:
    */

    double sum {100.2};
    unsigned int hours {8};
    unsigned int revenuePerHour { static_cast<unsigned int>(sum/hours) };  // revenuePerHour = 12
    cout << "Revenue per hour = " << revenuePerHour<< endl;

    float  ex1 = 3.66666666666666666666f;
    cout << "static_cast<double>(float) = " << static_cast<double>(ex1) << endl;

    cout << endl;
}

auto AssignmentOperators(){
    cout << "Assignment Operators:" << endl;

    int x {};
    x = 3 + 5;

    /*
    Все остальные операции присваивания являются сочетанием простой операции присваивания с другими операциями и имеют общую форму op=:

    +=: присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: A += B эквивалентно A = A + B
    -=: присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: A -= B эквивалентно A = A - B

    *=: присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: A *= B эквивалентно A = A * B

    /=: присваивание после деления. Присваивает левому операнду частное левого и правого операндов: A /= B эквивалентно A = A / B

    %=: присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: A %= B эквивалентно A = A % B

    <<=: присваивание после сдвига разрядов влево. Присваивает левому операнду результат сдвига его битового представления влево на определенное количество разрядов,
    равное значению правого операнда: A <<= B эквивалентно A = A << B

    >>=: присваивание после сдвига разрядов вправо. Присваивает левому операнду результат сдвига его битового представления вправо на определенное количество разрядов,
    равное значению правого операнда: A >>= B эквивалентно A = A >> B

    &=: присваивание после поразрядной конъюнкции. Присваивает левому операнду результат поразрядной конъюнкции его битового представления с битовым представлением
    правого операнда: A &= B эквивалентно A = A & B

    |=: присваивание после поразрядной дизъюнкции. Присваивает левому операнду результат поразрядной дизъюнкции его битового представления с битовым представлением
    правого операнда: A |= B эквивалентно A = A | B
    
    ^=: присваивание после операции исключающего ИЛИ. Присваивает левому операнду результат операции исключающего ИЛИ его битового представления с битовым представлением
    правого операнда: A ^= B эквивалентно A = A ^ B

    Примеры операций:
    */

    int a {5};
    a += 10;        // 15
    a -= 3;         // 12
    a *= 2;         // 24
    a /= 6;         // 4
    a <<= 4;  // 64
    a >>= 2;  // 16

    cout << endl;
} 

void ConditionalExpressions(){
    cout << "Conditional Expressions:" << endl;

    //Операции сравнения///////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    В языке программирования C++ есть следующие операции сравнения:
    ==
    >
    <
    <=
    >=
    !=
    */
    
    int a {10};
    int b {4};
    bool c {a == b};    // false
    bool d {a == 10};   // true
    	
    int aA {10};
    int bB {4};
    bool cC {a > b};  // true
    	
    bool cCC {10 < 4}; // false

    bool cc = 10 <= 4;    // false
    bool dd = 10 <= 14;   // true
    	
    bool cdd = 10 >= 4;    // true
    bool ddd = 10 >= 14;   // false
    	
    bool cD {10 != 4};   // true
    bool dc = 4 != 4;    // false

    //Чтобы вывести true/false, перед выводимым значением указывается манипулятор boolalpha:

    int num1 {8};
    int num2 {11};
    bool isBool1 {a == b};    // false
    bool isBool2 {a != b};    // true
    cout << "c = " << boolalpha << c << endl;  // c = false
    cout << "d = " << boolalpha << d << endl;  // d = true

    //Логические операции//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //Логические операции удобно применять для объединения операций сравнения или других логических операций:
    
    int A {5};
    int B {8};
    bool result1 = A ==5 && B > 8;  // если и a ==5, и b > 8
    bool result2 = A ==5 || B > 8;  // если или a ==5, или b > 8 (или оба варианты истины)

    // ^ ( XOR или eXclusive OR) Возвращает true, если хотя бы оба операнда имеют разные значения. Возвращает false, если оба операнда равны.
    bool result3 = A ==5 ^ B > 8;  // если оба операнда возвращают разные значения
 
    cout << "(a ==5 && b > 8) - " << boolalpha << result1 << endl;
    cout << "(a ==5 || b > 8) - " << boolalpha << result2 << endl;
    cout << "(a ==5 ^ b > 8) - " << boolalpha << result3 << endl;

    cout << endl;
}

void IfElseConstruct_TernaryOperator(){
    cout << "If-Else Construct and Ternary Operators:" << endl;

    //Полная запись конструкции ветвления if-else
    int n {21};

    if (n > 22)
    {
        cout << "n > 22" << endl;
    }
    else if (n < 22)
    {
        cout << "n < 22" << endl;
    }
    else
    {
        cout << "n == 22" << endl;
    }

    //Запись конструкции ветвления if-else с выполнением одной инструкции
    n = 21;
    if (n > 22)
        cout << "n > 22" << endl;
    else if (n < 22)
        cout << "n < 22" << endl;
    else
         cout << "n == 22" << endl;

    //Целочисленные условия/////////////////////////////////////////////////////////////////////////////////////////

    /*
    Стоит отметить, что если вместо значений типа bool передаются целые числа,
    то они преобразуются к типу bool- для нулевых значений возвращается false, для ненулевых - true, например:
    */

    int a {8};
    // a = true
    if(a) std::cout << "a = true" << std::endl; 
    else  std::cout << "a = false" << std::endl; 
     
    int b {};
    // b = false
    if(b) std::cout << "b = true" << std::endl; 
    else  std::cout << "b = false" << std::endl; 
    cout << endl;
}
int main()
{
    //g++ -std=c++20 -Wall -pedantic Chapter_1.cpp -o chapter_1; ./chapter_1

    //OutputInConsole(); //Вывод в консоль
    //DataTypes(); //Типы данных
    ///Constants(); //Константы
    //InputOutput(); //Ввод-Вывод в консоли
    //NamespaceUsing(); //using. Подключение пространств имен и определение псевдонимов
    //ArithmeticOperations(); //Арифметические операции
    //StaticTypingAndTypeConversions(); //Статическая типизация и преобразования типов
    //AssignmentOperators(); // Операции присваивания
    //ConditionalExpressions(); // Условные выражения
    //IfElseConstruct_TernaryOperator(); //Конструкция if-else и тернарный оператор

    return 0;
} 