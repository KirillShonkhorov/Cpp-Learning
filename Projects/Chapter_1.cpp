
#include <clocale>
#include <iomanip>
#include <iostream>
#include <ostream>

 using namespace std;

void OutputInConsole(){
    cout << "Output in console:" << endl;

    cout << "English: " << "Hello World!" << endl;
    setlocale(LC_ALL, "ru");
    cout << "Русский: " << "Привет мир!" << endl;

    cout << endl;
}

void Variables(){
    cout << "Variables types:" << endl;

    int age;
    int Age;
    int _age;

    int INT1 {123 + 123}, INT2 = 456 + 214, INT3 (789 / 12);

    //Нотация присваивания
    int Int;
    Int = 20;
    cout << "Int = " << Int << endl;

    //Инициализация в фигурных скобках 
    int FigureBracket {100};
    cout << "Figure Bracket = {" << FigureBracket << "}" << endl;

    //Функциональная нотация
    int Bracket (777);
    cout << "Bracket = (" << Bracket << ")" << endl;

    //Инициализация нулем
    int NullInt {};
    cout << "Null Int = {" << NullInt << "}" << endl;

    //Изменение значения
    int obj1 = 777;
    cout << "Object 1 = " << obj1 << endl;
    obj1 = 12345;
    cout << "Object 1 = " << obj1 << endl;

    cout << endl;
}

void DataTypes(){
    cout << "Data types:" << endl;

    //Логический тип////////////////////////////////////////////////////////////////////////
    bool isTrue {true};
    bool isFalse = false;
    bool DefaulBool;

    cout << "IsTrue = {" << isTrue << "}" << endl;
    cout << "IsFalse = " <<  isFalse << endl;
    cout << "Default Bool Value = " <<  DefaulBool << endl;

    //Целочисленные типы///////////////////////////////////////////////////////////////////////

    signed char schar = -127;//представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от -128 до 127

    unsigned char unschar = 255; //представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255

    char CHAR = 0; //Представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255
    /*
    Несмотря на то, что данный тип представляет тот же диапазон значений, что и вышеописанный тип signed char, но они не эквивалентны. 
    Тип char предназначен для хранения числового кода символа и в реальности может представлять как signed byte, так и unsigned byte в зависимости от конкретного компилятора.
    */

    short Short = -32768; //представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит).
    unsigned short UnShort = 65535; //представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит).

    int INT {-2147483648}; /*
               представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). 
               Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах).
                Но в любом случае размер должен быть больше или равен размеру типа short и меньше или равен размеру типа long 
            */
    cout << "INT = " <<  INT << endl;
    
    unsigned int unInt {4294967295}; /*
                            представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита),
                            и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт).
                          */
    cout << "Unsigned int = " <<  unInt << endl;

    long LONG {-2147483648}; /*
                            В зависимости от архитектуры может занимать 4 или 8 байт и представляет целое число в диапазоне от −2 147 483 648 до 2 147 483 647 (при 4 байтах)
                             или от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807 (при 8 байтах). Занимает в памяти 4 байта (32 бита) или.
                             */
    cout << "Long = " <<  LONG << endl;

    unsigned long UnLONG {4294967295}; //представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита).
    cout << "Unsigned Long = " <<  UnLONG << endl;

    long long LONG_LONG = -922337203685477580; //представляет целое число в диапазоне от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти 8 байт (64 бита).
    cout << "Long Long = " <<  LONG_LONG << endl;

    unsigned long long UnLONG_LONG = 1844674407370955165; //представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита).
    cout << "Unsigned Long Long = " <<  UnLONG_LONG << endl;

    int num{ 1'234'567'890 };
    cout << "num = " << num << "\n";   // num = 1234567890

    //Различные системы исчисления///////////////////////////////////////////////////////////////////////

    //16-ричная
    int num1{ 0x1A};        // 26 - в десятичной
    int num2{ 0xFF };       // 255 - в десятичной
    int num3{ 0xFFFFFF };   //16777215 - в десятичной

    //8-ричная
    int num4{ 034};        // 26 - в десятичной
    int num5{ 0377 };       // 255 - в десятичной

    //2-чная (бинарная) 
    int num6{ 0b11010};         // 26 - в десятичной
    int num7{ 0b11111111 };     // 255 - в десятичной

    //Числа с плавающей точкой///////////////////////////////////////////////////////////////////////

    /*
    Число с плавающей точкой состоит из двух частей: мантиссы и показателя степени. Оба могут быть как положительными, так и отрицательными. 
    Величина числа – это мантисса, умноженная на десять в степени экспоненты.
    Например, число 365 может быть записано в виде числа с плавающей точкой следующим образом:
    3.650000E02

    В качестве разделителя целой и дробной частей используется символ точки. Мантисса здесь имеет семь десятичных цифр - 3.650000, показатель степени - две цифры 02. 
    Буква E означает экспоненту, после нее указывается показатель степени (степени десяти), на которую умножается часть 3.650000 (мантисса), чтобы получить требуемое значение.
    То есть, чтобы вернуться к обычному десятичному представлению, нужно выполнить следующую операцию:
    3.650000 × 10^2 = 365

    Другой пример - возьмем небольшое число:
    -3.650000E-03
    В данном случае мы имеем дело с числом –3.65 × 10-3, что равно –0.00365. Здесь мы видим, что в зависимости от значения показателя степени десятичная точка "плавает". 
    Собственно поэтому их и называют числами с плавающей точкой.
    */

    //Даже если переменной присваивается целое число, чтобы показать, что мы присваиваем число с плавающей точкой, применяется точка
    double INT_DOUBLE {10.0}; //представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)
    double D_DOUBLE {123453.54345};

    // Чтобы показать, что число представляет другой тип, для float применяется суффикс f/F, а для long double - l/L
    float FLOAT {5.0f};//представляет вещественное число одинарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)
    long double LONG_DOUBLE {234634.42356546l};//представляет вещественное число двойной точности с плавающей точкой не менее 8 байт (64 бит). 
                                               //В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.

    float f_num{-100000000000000000000000000000000000000.0f / 3.0f};
    double d_num{-100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 / 3.0};
    long double l_d_num{10.0l / 3.0l};

    cout << setprecision(100) << f_num << endl; // вывод с максимальной точностью до 38 цифр. Требуется подключение <iomanip>
    cout << setprecision(1000) << d_num << endl; // вывод с максимальной точностью до 308 цифр. Требуется подключение <iomanip>
    cout << setprecision(1000) << l_d_num << endl; // вывод максимальной с точностью. Требуется подключение <iomanip>

    //Размеры типов данных///////////////////////////////////////////////////////////////////////

    /*
    Однако бывают ситуации, когда необходимо точно знать размер определенного типа. 
    И для этого в С++ есть оператор sizeof(), который возвращает размер памяти в байтах, которую занимает переменная.
    */
    long double LongDouble {6968956.275459845674362356544l};
    cout << "Size LongDouble = " << sizeof(LongDouble) << endl;

    //Символьные типы///////////////////////////////////////////////////////////////////////

    char IsChar {34}; //представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255
    wchar_t IsWCHAR {L'w'};//представляет расширенный символ. На Windows занимает в памяти 2 байта (16 бит), на Linux - 4 байта (32 бита). 
                            //Может хранить любой значение из диапазона от 0 до 65 535 (при 2 байтах), либо от 0 до 4 294 967 295 (для 4 байт)
    char16_t IsChar16t {u'L'};//представляет один символ в кодировке Unicode. Занимает в памяти 2 байта (16 бит). Может хранить любой значение из диапазона от 0 до 65 535
    char32_t IsChar32t {U'S'};//представляет один символ в кодировке Unicode. Занимает в памяти 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 4 294 967 295
    //wcout << "CHAR = " << IsChar << "\nCHAR16_T = " << IsChar16t << "\nCHAR32_T = " << IsChar32t << endl; 

    //Спецификатор auto///////////////////////////////////////////////////////////////////////

    auto number = 5;        // number имеет тип int
    auto sum {1234.56};    // sum имеет тип double
    auto distance {267UL};  // distance имеет тип unsigned long

    cout <<"Auto Int = "<< number <<"\nAuto Double = "<< sum <<"\nAuto Unsigned Long = "<< distance << endl;

    cout << endl;
}

void Constants(){
    cout << "Constants:" << endl;

    const int n {22};

    int a {10};
    const int b {7};
    const int d {b};
    const int x {a};

    cout << "Constants: " << n << ", " << b << ", " << d << ", " << x << endl;

    cout << endl;
}
  git branch -M main
  git remote add origin https://github.com/KirillShonkhorov/Cpp-Learning.git
void InputOutput(){
    cout << "Input and Output in console:" << endl;

    short age {33};
    double weight {81.23};

    cout << "Name: " << "Tom" << "\n"; // необходимо подключить библиотеку iostream
    cout << "Age: " << age << endl; // необходимо подключить библиотеку iostream
    cout << "Weight: " << weight << endl; //  необходимо подключить библиотеку iostream

    int age2;
    double weight2;
    cout << "Input age: ";
    cin >> age2;// необходимо подключить библиотеку iostream
    cout << "Input weight: ";
    cin >> weight2;// необходимо подключить библиотеку iostream
    cout << "Age2: " << age2 << "\t Weight2: " << weight2 << endl;

    cout << endl;
}

void NamespaceUsing(){
    cout << "Using namespaces and pseudonyms:" << endl;

    /*
    При чтении и записи в предыдущих темах использовались объекты cout и cin соответственно. Причем они использовались с префиксом . 
    Этот префикс указывает, что объекты cout, cin, endl определены в пространстве имен std. 
    А само двойное двоеточие :: представляет оператор области видимости (scope operator), который позволяет указать, в каком пространстве имен определен объект. 
    И без префикса эти объекты по умолчанию мы использовать не можем.
    */
    using std::cout;
    using std::endl;
    cout << ":: = SCOPE OPERATOR" << endl;

    //Определение псевдонимов///////////////////////////////////////////////////////////////////////

    /*
    Ключевое слово using также позволяет определять псевдонимы для типов.
    Это может пригодиться, когда мы работаем с типами с длинными названиями, а определение коротких псевдонимов позволит сократить код.
    */
    using ull = unsigned long long;

    ull ULL = {23522354234};
    cout << "Unsigned Long Long is \"ull\" = " << ULL << endl;

    cout << endl;
}

void ArithmeticOperations(){
    cout << "Arithmetic Operations:" << endl;

    //Арифметические операции///////////////////////////////////////////////////////////////////////////////////////////////////////

    short AplusB {10+40};
    cout << "Plus: " << "10 + 40 = " << AplusB << endl;

    short AminusB = 100-77;
    cout << "Minus: " << "100 - 77 = " << AminusB << endl;
    
    short AmultiplicationB (4*16);
    cout << "Multiplication: " << "4 * 16 = " << AmultiplicationB << endl;

    short AdivisionB = {300/200};
    cout << "Division: " << "300 / 200 = " << AdivisionB << endl;

    float Adivision_floatB = {300.0f /65.0f};
    cout << "Division float: " << "300.0f / 65.0f = " << Adivision_floatB << endl;

    short AremainderB = {300%75};
    cout << "Remainder: " << "300 % 75 = " << AremainderB << endl;

    //Некоторые особенности при работе с числами с плавающей точкой///////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    При сложении или вычитании чисел с плавающей точкой, которые сильно отличаются по значению, следует проявлять осторожность. 
    Например, сложим число 1.23E-4 (0.000123) и 3.65E+6 (3650000). Мы ожидаем, что сумма будет равна 3650000,000123. 
    Но при преобразовании в число с плавающей запятой с точностью до семи цифр это становится следующим
    */
    float num1{ 1.23E-4  };        // 0.000123
    float num2{ 3.65E+6  };        // 3650000
    float sum {num1 + num2};       // sum = 3.65e+06
    cout << "sum =" << sum << "\n";

    /*
    Также стоит отметить, что стандарт IEEE, который реализуется компиляторами С++, определяет специальные значения для чисел с плавающей точкой,
    в которых мантисса на бинарном уровне состоит только из нулей, а экспонента, которая состоит из одних единиц,
    в зависимости от знака представляет значения +infinity (плюс бесконечность +∞) и -infinity (минус бесконечность -∞).
    И при делении положительного числа на ноль, результатом будет +infinity, а при делении отрицательного числа на ноль - -infinity.

    Другое специальное значение с плавающей точкой, определенное этим стандартом, представляет значение NaN (не число). 
    Это значение представляет результат операции, который не определяется математически, например, когда ноль делится на ноль или бесконечность на бесконечность. 
    Результатом любой операции, в которой один или оба операнда являются NaN, также является NaN.
    */
    double a{ 1.5 }, b{}, c{}, d {-1.5};
    double result { a / b };
    cout << a << "/" << b << " = " << result << endl;
    result = d / c;
    cout << d << "/" << c << " = " << result << endl;
    result = b / c;
    cout << b << "/" << c << " = " << result << endl;
    cout << result << " + " << a << " = " << result + a << endl;

    //Инкремент и декремент////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Также есть две унарные арифметические операции, которые производятся над одним числом: ++ (инкремент) и -- (декремент). 
    Каждая из операций имеет две разновидности: префиксная и постфиксная
    */

    //префиксный инкремент
    short exam {100};
    short prefix {++exam};
    cout << "exam = " << exam << endl;
    cout << "prefix = " << prefix << endl;

    //постфиксный инкремент
    exam = {100};
    prefix = {exam++};
    cout << "exam = " << exam << endl;
    cout << "prefix = " << prefix << endl;

    //префиксный декремент
    exam = {100};
    prefix = {--exam};
    cout << "exam = " << exam << endl;
    cout << "prefix = " << prefix << endl;

    //постфиксный декремент
    exam = {100};
    prefix = {exam--};
    cout << "exam = " << exam << endl;
    cout << "prefix = " << prefix << endl;

    //Приоритет и ассоциативность операторов/////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Операции в порядке уменьшения приоритета:
    () (Переопределение порядка)
    ++ (инкремент), -- (декремент)
    * (умножение), / (деление), % (остаток от деления)
    + (сложение), - (вычитание)
    */

    short number1 {8};
    short number2 {7};
    int number3 {(number1 + 5) * ++number2};      // c = 104
    cout << "number3 = " << number3 << endl;

    cout << endl;
}

int main()                         
{          
    //OutputInConsole(); //Вывод в консоль
    //DataTypes(); //Типы данных
    //Constants(); //Константы
    //InputOutput(); //Ввод-Вывод в консоли
    //NamespaceUsing(); //using. Подключение пространств имен и определение псевдонимов
    //ArithmeticOperations();//Арифметические операции
    return 0;
} 