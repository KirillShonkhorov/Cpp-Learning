
#include <clocale>
#include <iomanip>
#include <iostream>
#include <iterator>
#include <ostream>
#include <string>

 using namespace std;

void OutputInConsole(){
    cout << "Output in console:" << endl;

    cout << "English: " << "Hello World!" << endl;
    setlocale(LC_ALL, "ru"); //#include <clocale>
    cout << "Русский: " << "Привет мир!" << endl;

    cout << endl;
}

void Variables(){
    cout << "Variables types:" << endl;

    int age;
    int Age;
    int _age;

    int INT1 {123 + 123}, INT2 = 456 + 214, INT3 (789 / 12);

    //Нотация присваивания
    int Int;
    Int = 20;
    cout << "Int = " << Int << endl;

    //Инициализация в фигурных скобках 
    int FigureBracket {100};
    cout << "Figure Bracket = {" << FigureBracket << "}" << endl;

    //Функциональная нотация
    int Bracket (777);
    cout << "Bracket = (" << Bracket << ")" << endl;

    //Инициализация нулем
    int NullInt {};
    cout << "Null Int = {" << NullInt << "}" << endl;

    //Изменение значения
    int obj1 = 777;
    cout << "Object 1 = " << obj1 << endl;
    obj1 = 12345;
    cout << "Object 1 = " << obj1 << endl;

    cout << endl;
}

void DataTypes(){
    cout << "Data types:" << endl;

    //Логический тип////////////////////////////////////////////////////////////////////////
    bool isTrue {true};
    bool isFalse = false;
    bool DefaulBool; //false

    cout << "IsTrue = {" << isTrue << "}" << endl;
    cout << "IsFalse = " <<  isFalse << endl;
    cout << "Default Bool Value = " <<  DefaulBool << endl;

    //Целочисленные типы///////////////////////////////////////////////////////////////////////

    signed char schar = -127;//представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от -128 до 127

    unsigned char unschar = 255; //представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255

    char CHAR = 0; //Представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255
    /*
    Несмотря на то, что данный тип представляет тот же диапазон значений, что и вышеописанный тип signed char, но они не эквивалентны. 
    Тип char предназначен для хранения числового кода символа и в реальности может представлять как signed byte, так и unsigned byte в зависимости от конкретного компилятора.
    */

    short Short = -32768; //представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит).
    unsigned short UnShort = 65535; //представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит).

    int INT {-2147483648}; /*
               представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). 
               Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах).
                Но в любом случае размер должен быть больше или равен размеру типа short и меньше или равен размеру типа long 
            */
    cout << "INT = " <<  INT << endl;
    
    unsigned int unInt {4294967295}; /*
                            представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита),
                            и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт).
                          */
    cout << "Unsigned int = " <<  unInt << endl;

    long LONG {-2147483648}; /*
                            В зависимости от архитектуры может занимать 4 или 8 байт и представляет целое число в диапазоне от −2 147 483 648 до 2 147 483 647 (при 4 байтах)
                             или от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807 (при 8 байтах). Занимает в памяти 4 байта (32 бита) или.
                             */
    cout << "Long = " <<  LONG << endl;

    unsigned long UnLONG {4294967295}; //представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита).
    cout << "Unsigned Long = " <<  UnLONG << endl;

    long long LONG_LONG = -922337203685477580; //представляет целое число в диапазоне от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти 8 байт (64 бита).
    cout << "Long Long = " <<  LONG_LONG << endl;

    unsigned long long UnLONG_LONG = 1844674407370955165; //представляет целое число в диапазоне от 0 до 1 844 674 407 370 955 165. Занимает в памяти 8 байт (64 бита).
    cout << "Unsigned Long Long = " <<  UnLONG_LONG << endl;

    int num{ 1'234'567'890 };
    cout << "num = " << num << "\n";   // num = 1234567890

    //Различные системы исчисления///////////////////////////////////////////////////////////////////////

    //16-ричная
    int num1{ 0x1A};        // 26 - в десятичной
    int num2{ 0xFF };       // 255 - в десятичной
    int num3{ 0xFFFFFF };   //16777215 - в десятичной

    //8-ричная
    int num4{ 034};        // 26 - в десятичной
    int num5{ 0377 };       // 255 - в десятичной

    //2-чная (бинарная) 
    int num6{ 0b11010};         // 26 - в десятичной
    int num7{ 0b11111111 };     // 255 - в десятичной

    //Числа с плавающей точкой///////////////////////////////////////////////////////////////////////

    /*
    Число с плавающей точкой состоит из двух частей: мантиссы и показателя степени. Оба могут быть как положительными, так и отрицательными. 
    Величина числа – это мантисса, умноженная на десять в степени экспоненты.
    Например, число 365 может быть записано в виде числа с плавающей точкой следующим образом:
    3.650000E02

    В качестве разделителя целой и дробной частей используется символ точки. Мантисса здесь имеет семь десятичных цифр - 3.650000, показатель степени - две цифры 02. 
    Буква E означает экспоненту, после нее указывается показатель степени (степени десяти), на которую умножается часть 3.650000 (мантисса), чтобы получить требуемое значение.
    То есть, чтобы вернуться к обычному десятичному представлению, нужно выполнить следующую операцию:
    3.650000 × 10^2 = 365

    Другой пример - возьмем небольшое число:
    -3.650000E-03
    В данном случае мы имеем дело с числом –3.65 × 10-3, что равно –0.00365. Здесь мы видим, что в зависимости от значения показателя степени десятичная точка "плавает". 
    Собственно поэтому их и называют числами с плавающей точкой.
    */

    //Даже если переменной присваивается целое число, чтобы показать, что мы присваиваем число с плавающей точкой, применяется точка
    double INT_DOUBLE {10.0}; //представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)
    double D_DOUBLE {123453.54345};

    // Чтобы показать, что число представляет другой тип, для float применяется суффикс f/F, а для long double - l/L
    float FLOAT {5.0f};//представляет вещественное число одинарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)
    long double LONG_DOUBLE {234634.42356546l};//представляет вещественное число двойной точности с плавающей точкой не менее 8 байт (64 бит). 
                                               //В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.

    float f_num{-100000000000000000000000000000000000000.0f / 3.0f};
    double d_num{-100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 / 3.0};
    long double l_d_num{10.0l / 3.0l};

    cout << setprecision(100) << f_num << endl; // вывод с максимальной точностью до 38 цифр. Требуется подключение <iomanip>
    cout << setprecision(1000) << d_num << endl; // вывод с максимальной точностью до 308 цифр. Требуется подключение <iomanip>
    cout << setprecision(1000) << l_d_num << endl; // вывод максимальной с точностью. Требуется подключение <iomanip>

    //Размеры типов данных///////////////////////////////////////////////////////////////////////

    /*
    Однако бывают ситуации, когда необходимо точно знать размер определенного типа. 
    И для этого в С++ есть оператор sizeof(), который возвращает размер памяти в байтах, которую занимает переменная.
    */
    long double LongDouble {6968956.275459845674362356544l};
    cout << "Size LongDouble = " << sizeof(LongDouble) << endl;

    //Символьные типы///////////////////////////////////////////////////////////////////////

    char IsChar {34}; //представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255
    wchar_t IsWCHAR {L'w'};//представляет расширенный символ. На Windows занимает в памяти 2 байта (16 бит), на Linux - 4 байта (32 бита). 
                            //Может хранить любой значение из диапазона от 0 до 65 535 (при 2 байтах), либо от 0 до 4 294 967 295 (для 4 байт)
    char16_t IsChar16t {u'L'};//представляет один символ в кодировке Unicode. Занимает в памяти 2 байта (16 бит). Может хранить любой значение из диапазона от 0 до 65 535
    char32_t IsChar32t {U'S'};//представляет один символ в кодировке Unicode. Занимает в памяти 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 4 294 967 295
    //wcout << "CHAR = " << IsChar << "\nCHAR16_T = " << IsChar16t << "\nCHAR32_T = " << IsChar32t << endl; 

    //Спецификатор auto///////////////////////////////////////////////////////////////////////

    /*
    Спецификатор auto следует использовать в неопределённых ситуациях, когда явно определить тип переменной затруднительно.
    Auto практически не влияет на производительность кода, так что его использование никак не замедлит код.
    При явном определении типов переменных следует использовать явные типы данных - это более читаемо.
    */

    auto number = 5;        // number имеет тип int
    auto sum {1234.56};    // sum имеет тип double
    auto distance {267UL};  // distance имеет тип unsigned long

    auto InputData(0);
    cout << "Input Auto Data: ";
    cin >> InputData;

    cout <<"Auto Int = "<< number <<"\nAuto Double = "<< sum <<"\nAuto Unsigned Long = "<< distance<<"\nAuto Input = "<< InputData << endl;

    cout << endl;
}

void Constants(){
    cout << "Constants:" << endl;

    //Константы следует именовать с больших букв (CONST_VARIABLE = 100)
    const int n {22};

    int a {10};
    const int b {7};
    const int d {b};
    const int x {a};

    cout << "Constants: " << n << ", " << b << ", " << d << ", " << x << endl;

    cout << endl;
}

void InputOutput(){
    cout << "Input and Output in console:" << endl;

    short age {33};
    double weight {81.23};

    cout << "Name: " << "Tom" << "\n"; // необходимо подключить библиотеку iostream
    cout << "Age: " << age << endl; // необходимо подключить библиотеку iostream
    cout << "Weight: " << weight << endl; //  необходимо подключить библиотеку iostream

    int age2;
    double weight2;
    cout << "Input age: ";
    cin >> age2;// необходимо подключить библиотеку iostream
    cout << "Input weight: ";
    cin >> weight2;// необходимо подключить библиотеку iostream
    cout << "Age2: " << age2 << "\t Weight2: " << weight2 << endl;

    cout << endl;
}

void NamespaceUsing(){
    cout << "Using namespaces and pseudonyms:" << endl;

    /*
    При чтении и записи в предыдущих темах использовались объекты cout и cin соответственно. Причем они использовались с префиксом . 
    Этот префикс указывает, что объекты cout, cin, endl определены в пространстве имен std. 
    А само двойное двоеточие :: представляет оператор области видимости (scope operator), который позволяет указать, в каком пространстве имен определен объект. 
    И без префикса эти объекты по умолчанию мы использовать не можем.
    */
    using std::cout;
    using std::endl;
    cout << ":: = SCOPE OPERATOR" << endl;

    //Определение псевдонимов///////////////////////////////////////////////////////////////////////

    /*
    Ключевое слово using также позволяет определять псевдонимы для типов.
    Это может пригодиться, когда мы работаем с типами с длинными названиями, а определение коротких псевдонимов позволит сократить код.
    */
    using ull = unsigned long long;

    ull ULL = {23522354234};
    cout << "Unsigned Long Long is \"ull\" = " << ULL << endl;

    cout << endl;
}

void ArithmeticOperations(){
    cout << "Arithmetic Operations:" << endl;

    //Арифметические операции///////////////////////////////////////////////////////////////////////////////////////////////////////

    short AplusB {10+40};
    cout << "Plus: " << "10 + 40 = " << AplusB << endl;

    short AminusB = 100-77;
    cout << "Minus: " << "100 - 77 = " << AminusB << endl;
    
    short AmultiplicationB (4*16);
    cout << "Multiplication: " << "4 * 16 = " << AmultiplicationB << endl;

    short AdivisionB = {300/200};
    cout << "Division: " << "300 / 200 = " << AdivisionB << endl;

    float Adivision_floatB = {300.0f /65.0f};
    cout << "Division float: " << "300.0f / 65.0f = " << Adivision_floatB << endl;

    short AremainderB = {300%75};
    cout << "Remainder: " << "300 % 75 = " << AremainderB << endl;

    //Некоторые особенности при работе с числами с плавающей точкой///////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    При сложении или вычитании чисел с плавающей точкой, которые сильно отличаются по значению, следует проявлять осторожность. 
    Например, сложим число 1.23E-4 (0.000123) и 3.65E+6 (3650000). Мы ожидаем, что сумма будет равна 3650000,000123. 
    Но при преобразовании в число с плавающей запятой с точностью до семи цифр это становится следующим
    */
    float num1{ 1.23E-4  };        // 0.000123
    float num2{ 3.65E+6  };        // 3650000
    float sum {num1 + num2};       // sum = 3.65e+06
    cout << "sum =" << sum << "\n";

    /*
    Также стоит отметить, что стандарт IEEE, который реализуется компиляторами С++, определяет специальные значения для чисел с плавающей точкой,
    в которых мантисса на бинарном уровне состоит только из нулей, а экспонента, которая состоит из одних единиц,
    в зависимости от знака представляет значения +infinity (плюс бесконечность +∞) и -infinity (минус бесконечность -∞).
    И при делении положительного числа на ноль, результатом будет +infinity, а при делении отрицательного числа на ноль - -infinity.

    Другое специальное значение с плавающей точкой, определенное этим стандартом, представляет значение NaN (не число). 
    Это значение представляет результат операции, который не определяется математически, например, когда ноль делится на ноль или бесконечность на бесконечность. 
    Результатом любой операции, в которой один или оба операнда являются NaN, также является NaN.
    */
    double a{ 1.5 }, b{}, c{}, d {-1.5};
    double result { a / b };
    cout << a << "/" << b << " = " << result << endl; // +inf
    result = d / c;
    cout << d << "/" << c << " = " << result << endl; // -inf
    result = b / c;
    cout << b << "/" << c << " = " << result << endl; // NaN
    cout << result << " + " << a << " = " << result + a << endl; // NaN

    //Инкремент и декремент////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Также есть две унарные арифметические операции, которые производятся над одним числом: ++ (инкремент) и -- (декремент). 
    Каждая из операций имеет две разновидности: префиксная и постфиксная
    */

    //префиксный инкремент
    short exam {100};
    short prefix {++exam};
    cout << "exam = " << exam << endl;
    cout << "prefix = " << prefix << endl;

    //постфиксный инкремент
    exam = {100};
    prefix = {exam++};
    cout << "exam = " << exam << endl;
    cout << "prefix = " << prefix << endl;

    //префиксный декремент
    exam = {100};
    prefix = {--exam};
    cout << "exam = " << exam << endl;
    cout << "prefix = " << prefix << endl;

    //постфиксный декремент
    exam = {100};
    prefix = {exam--};
    cout << "exam = " << exam << endl;
    cout << "prefix = " << prefix << endl;

    //Приоритет и ассоциативность операторов/////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Операции в порядке уменьшения приоритета:
    () (Переопределение порядка)
    ++ (инкремент), -- (декремент)
    * (умножение), / (деление), % (остаток от деления)
    + (сложение), - (вычитание)
    */

    short number1 {8};
    short number2 {7};
    int number3 {(number1 + 5) * ++number2};      // number3 = 104
    cout << "number3 = " << number3 << endl;

    cout << endl;
}

void StaticTypingAndTypeConversions(){
    cout << "Static Typing And Type Conversions:" << endl;

    //Примеры неявных преобразований////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //Переменной типа bool присваивается значение другого типа. В этом случае переменная получает false, если значение равно 0.
    //Во всех остальных случаях переменная получает true.
    bool a = 1;     // true
    bool b = 0;     // false
    bool c = 'g'; // true
    bool d = 3.4;   // true

    //Числовой или символьной переменной присваивается значение типа bool. В этом случае переменная получает 1, если значение равно true,
    //либо получает 0, если присваиваемое значение равно false.
    int e = true;       // 1
    double f = false;   // 0

    //Целочисленной переменной присваивается дробное число. В этом случае дробная часть после запятой отбрасывается.
    int g = 3.4;        // 3
    int h = 3.6;        // 3

    //Переменной, которая представляет тип с плавающей точкой, присваивается целое число.
    //В этом случае, если целое число содержит больше битов, чем может вместить тип переменной, то часть информации усекается.
    float k = 35005;                // 35005
    double l = 3500500000033;       // 3.5005e+012

    /*
    Переменной беззнакового типа (unsigned) присваивается значение не из его диапазона. В этом случае результатом будет остаток от деления по модулю.
    Например, тип unsigned char может хранить значения от 0 до 255. Если присвоить ему значение вне этого диапазона,
    то компилятор присвоит ему остаток от деления по модулю 256 (так как тип unsigned char может хранить 256 значений).
    Так, при присвоении значения -5 переменная типа unsigned char получит значение 251
    */
    unsigned char m = -5;           // 251
    unsigned short n = -3500;       // 62036
    unsigned int o = -50000000;     // 4244967296

    //Преобразования в арифметических операциях//////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    В арифметических операциях необходимо, чтобы оба операнда представляли один и тот же тип. Если же операнды имеют разные типы,
    то компилятор автоматически выбирает операнд с типом который имеет меньший диапазон значений и пытается его преобразовать в тип второго операнда,
    который имеет больший диапазон значений. С точки зрения преобразований в операциях типы можно расположить следующим образом в порядке приоритета
    (от более высокого к более низкому):

    1) long double
    2) double
    3) float
    4) unsigned long long
    5) long long
    6) unsigned long
    7) long
    8) unsigned int
    9) int
    */

    //Опасные и безопасные преобразования//////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Те преобразования, при которых не происходит потеря информации, являются безопасными. Как правило, это преобразования от типа с меньшей разрядностью к типу с большей разрядностью.
    В частности, это следующие цепочки преобразований:

    1) bool -> char -> short -> int -> double -> long double
    2) bool -> char -> short -> int -> long -> long long
    3) unsigned char -> unsigned short -> unsigned int -> unsigned long
    4) float -> double -> long double
    */
    
    short p = 'g'; // преобразование из char в short
    int r = 10;
    double s = r; // преобразование из int в double
    float t = 3.4;
    double u = t; // преобразование из float в double
    double x = 35; // преобразование из int в double

    //Явные преобразования типов///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //Для выполнения явных преобразований типов (explicit type conversion) применяется оператор static_cast
    //static_cast<type>(value)

    /*
    Данный оператор преобразует значение в круглых скобках - value к типу, который указан в угловых скобках - type.
    Слово static в названии оператора отражает тот факт, что приведение проверяется статически, то есть во время компиляции.
    Применение оператора static_cast указывает компилятору, что мы уверены, что в этом месте надо применить преобразование, поэтому даже при инициализации в фигурных скобках компилятор не сгенерирует ошибку.
    Например, программист заработал за 8 часовой рабочий день 100,2$, рассчитаем его заработок за час, но в виде значения unsigned int:
    */

    double sum {100.2};
    unsigned int hours {8};
    unsigned int revenuePerHour { static_cast<unsigned int>(sum/hours) };  // revenuePerHour = 12
    cout << "Revenue per hour = " << revenuePerHour<< endl;

    float  ex1 = 3.66666666666666666666f;
    cout << "static_cast<double>(float) = " << static_cast<double>(ex1) << endl;

    cout << endl;
}

auto AssignmentOperators(){
    cout << "Assignment Operators:" << endl;

    int x {};
    x = 3 + 5;

    /*
    Все остальные операции присваивания являются сочетанием простой операции присваивания с другими операциями и имеют общую форму op=:

    +=: присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: A += B эквивалентно A = A + B
    -=: присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: A -= B эквивалентно A = A - B

    *=: присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: A *= B эквивалентно A = A * B

    /=: присваивание после деления. Присваивает левому операнду частное левого и правого операндов: A /= B эквивалентно A = A / B

    %=: присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: A %= B эквивалентно A = A % B

    <<=: присваивание после сдвига разрядов влево. Присваивает левому операнду результат сдвига его битового представления влево на определенное количество разрядов,
    равное значению правого операнда: A <<= B эквивалентно A = A << B

    >>=: присваивание после сдвига разрядов вправо. Присваивает левому операнду результат сдвига его битового представления вправо на определенное количество разрядов,
    равное значению правого операнда: A >>= B эквивалентно A = A >> B

    &=: присваивание после поразрядной конъюнкции. Присваивает левому операнду результат поразрядной конъюнкции его битового представления с битовым представлением
    правого операнда: A &= B эквивалентно A = A & B

    |=: присваивание после поразрядной дизъюнкции. Присваивает левому операнду результат поразрядной дизъюнкции его битового представления с битовым представлением
    правого операнда: A |= B эквивалентно A = A | B
    
    ^=: присваивание после операции исключающего ИЛИ. Присваивает левому операнду результат операции исключающего ИЛИ его битового представления с битовым представлением
    правого операнда: A ^= B эквивалентно A = A ^ B

    Примеры операций:
    */

    int a {5};
    a += 10;        // 15
    a -= 3;         // 12
    a *= 2;         // 24
    a /= 6;         // 4
    a <<= 4;  // 64
    a >>= 2;  // 16

    cout << endl;
} 

void ConditionalExpressions(){
    cout << "Conditional Expressions:" << endl;

    //Операции сравнения///////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    В языке программирования C++ есть следующие операции сравнения:
    ==
    >
    <
    <=
    >=
    !=
    */
    
    int a {10};
    int b {4};
    bool c {a == b};    // false
    bool d {a == 10};   // true
    	
    int aA {10};
    int bB {4};
    bool cC {a > b};  // true
    	
    bool cCC {10 < 4}; // false

    bool cc = 10 <= 4;    // false
    bool dd = 10 <= 14;   // true
    	
    bool cdd = 10 >= 4;    // true
    bool ddd = 10 >= 14;   // false
    	
    bool cD {10 != 4};   // true
    bool dc = 4 != 4;    // false

    //Чтобы вывести true/false, перед выводимым значением указывается манипулятор boolalpha:

    int num1 {8};
    int num2 {11};
    bool isBool1 {a == b};    // false
    bool isBool2 {a != b};    // true
    cout << "c = " << boolalpha << c << endl;  // c = false
    cout << "d = " << boolalpha << d << endl;  // d = true

    //Логические операции//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //Логические операции удобно применять для объединения операций сравнения или других логических операций:
    
    int A {5};
    int B {8};
    bool result1 = A ==5 && B > 8;  // если и a ==5, и b > 8
    bool result2 = A ==5 || B > 8;  // если или a ==5, или b > 8 (или оба варианты истины)

    // ^ ( XOR или eXclusive OR) Возвращает true, если хотя бы оба операнда имеют разные значения. Возвращает false, если оба операнда равны.
    bool result3 = A ==5 ^ B > 8;  // если оба операнда возвращают разные значения
 
    cout << "(a ==5 && b > 8) - " << boolalpha << result1 << endl;
    cout << "(a ==5 || b > 8) - " << boolalpha << result2 << endl;
    cout << "(a ==5 ^ b > 8) - " << boolalpha << result3 << endl;

    cout << endl;
}

void IfElseConstruct_TernaryOperator(){
    cout << "If-Else Construct and Ternary Operators:" << endl;

    //Полная запись конструкции ветвления if-else
    int n {21};

    if (n > 22)
    {
        cout << "n > 22" << endl;
    }
    else if (n < 22)
    {
        cout << "n < 22" << endl;
    }
    else
    {
        cout << "n == 22" << endl;
    }

    //Запись конструкции ветвления if-else с выполнением одной инструкции
    n = 21;
    if (n > 22)
        cout << "n > 22" << endl;
    else if (n < 22)
        cout << "n < 22" << endl;
    else
         cout << "n == 22" << endl;

    //Целочисленные условия/////////////////////////////////////////////////////////////////////////////////////////

    /*
    Стоит отметить, что если вместо значений типа bool передаются целые числа,
    то они преобразуются к типу bool- для нулевых значений возвращается false, для ненулевых - true, например:
    */

    int a {8};
    // a = true
    if(a) cout << "a = true" << endl; 
    else  cout << "a = false" << endl; 
     
    int b {};
    // b = false
    if(b) cout << "b = true" << endl; 
    else  cout << "b = false" << endl; 

    //Вложенные конструкции////////////////////////////////////////////////////////////////////////////////////

    if(a==5)
    {
        if(b==8)
        { 
            cout << "b == 8" << endl;
        }
        else
        {
            cout << "b != 8" << endl;
        }
        cout << "a == 5" << endl;
    }
    else
    {
        cout << "a != 5 " << endl;
    }

    //Блок if с инициализацией переменной/////////////////////////////////////////////////////////////////////

    if(int c {a - b}; a > b)
    {
        cout << "a=" << a << "; c=" << c << endl;
    }
    else
    {
        cout << "b=" << b << "; c=" << c << endl;
    }

    //Тернарный оператор///////////////////////////////////////////////////////////////////////////////////

    /*
    Тернарный оператор в некотором роде похож на конструкцию if-else. Он принимает три операнда в следующем виде:
	
    операнд1? операнд2 : операнд3

    Первый операнд представляет условие. Если это условие верно (равно true), тогда выбирается/выполняется второй операнд,
    который помещается после символа ?. Если условие не верно, тогда выбирается/выполняется третий операнд, который помещается после двоеточия.
    */

    a = 5;
    b  = 8;
    int c = a > b ? a - b : a + b; // c = if(a > b) to
                                   //     a - b
                                   //else a + b
 
    cout << "c = " << c << endl;  // c = 13

    //В рамках одного тернарного оператора можно комбинировать несколько других. Например:

    cout << (a < b ? "a is less than b" :
        (a == b ? "a is equal to b" : "a is greater than b"));

    cout << endl << endl;
   }

void SwitchCaseConstruction(){
    cout << "Switch-case construction:" << endl;

    int x {2};
      
    switch(x) //что сравниваем
    {
        case 1: // X = 1 ?
            cout << "x = 1" << "\n";
            break; // Прекращает выполнение конструкции switch-case
        case 2: // X = 2 ?
            cout << "x = 2" << "\n";
            break; // Прекращает выполнение конструкции switch-case
        case 3: // X = 3 ?
            cout << "x = 3" << "\n";
            break; // Прекращает выполнение конструкции switch-case
        default: //Если ни один из блоков case не выполнен.
            cout << "x is undefined" << "\n";
            break; // Прекращает выполнение конструкции switch-case
    }

    //Совмещение условий//////////////////////////////////////////////////////////////////////////////////////////

    //Можно определять для нескольких меток case один набор инструкций:

    switch(x)
    {
        case 1: //Здесь если x=1 или x=2, то выполняется одна и та же инструкция
        case 2:     
            cout << "x = 1 or 2" << "\n";
            break;
        case 3: 
        case 4:
            cout << "x = 3 or 4" << "\n";
            break;
        case 5:
            cout << "x = 5" << "\n";
            break;
    }

    //Переменные в блоках case////////////////////////////////////////////////////////////////////////////

    /*
    Определение переменных в блоках case, возможно, встречается нечасто. Однако может вызвать затруднения.
    Так, если переменная определяется в блоке case, то все инструкции блока помещаются в фигурные скобки (для блока default это не требуется):
    */

    switch(x)
    {
        case 1:
        {
            int a{10};
            cout << a << endl;
            break;
        }
        case 2:
        {
            int b{20};
            cout << b << endl;
            break;
        }
        default:
            int c{30};
            cout << c << endl;
    }

    //Блок switch с инициализацией переменной///////////////////////////////////////////////////////////////

    char op = '+';
    int n = 10;
    switch(int k{2}; op)
    {
        case '+':
            std::cout << n + k << std::endl;
            break;
        case '-':
            std::cout << n - k << std::endl;
            break;
        case '*':
            std::cout << n * k << std::endl;
            break;
    }

    /*
    В данном случае в конструкции switch определяется переменная k, которая доступна только в рамках этой конструкции switch.
    В качестве выражения используется значение переменной op, которая представляет знак операции.
    И в зависимости от этого значения, выполняем определенную операцию с переменными n и k.
    */

    cout << endl;
}

void Cycles(){
    cout << "Cycles:" << endl;
    
    //Цикл while///////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    После ключевого слова while в скобках идет условное выражение, которое возвращает true или false.
    Затем в фигурных скобках идет набор инструкций, которые составляют тело цикла.
    И пока условие возвращает true, будут выполняться инструкции в теле цикла.

    Например, выведем квадраты чисел от 1 до 9:
    */

    int i {1};
    while(i < 10)
    {
        std::cout << i << " * " << i << " = " << i * i << std::endl;
        i++;
    }

    cout << endl;

    //Если цикл содержит одну инструкцию, то фигурные скобки можно опустить:

    int j {};
    while(++j < 10)
        std::cout << j << " * " << j << " = " << j * j << std::endl;
    
    cout << endl;

    //Цикл for////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Цикл for имеет следующее формальное определение:
	
    for (инициализатор; условие; итерация)
    {
        тело цикла
    }

    Инициализатор выполняется один раз при начале выполнения цикла и представляет установку начальных условий,
    как правило, это инициализация счетчиков - специальных переменных, которые используются для контроля за циклом.

    Условие представляет условие, при соблюдении которого выполняется цикл.
    Как правило, в качестве условия используется операция сравнения, и если она возвращает ненулевое значение (то есть условие истинно),
    то выполняется тело цикла, а затем выполняется итерация.

    Итерация выполняется после каждого завершения блока цикла и задает изменение параметров цикла.
    Обычно здесь происходит увеличение счетчиков цикла.
    */

    for(int i {1}; i < 10; i++)
    {
        std::cout << i << " * " << i << " = " << i * i << std::endl;
    }

    cout << endl;

    //Необязательно указывать все три выражения в определении цикла, мы можем одно или даже все из них опустить:

    i  = 1;
    for(; i < 10;)
    {
        std::cout << i << " * " << i << " = " << i * i << std::endl;
        i++;
    }

    cout << endl;

    //Также цикл не обязательно должен содержать тело. Например, вычислим с помощью цикла сумму чисел от 1 до 5:

    int sum {};
    for (unsigned i {}; i < 6; sum += i++);
    std::cout << "Sum: " << sum << std::endl;   // Sum: 15

    cout << endl;

    //Выражение инициализации может определять больше одной переменной. Например, определим две переменных и выведем на консоль их произведение:

    int numbers[]{1, 2, 3, 4};
    sum = 0;
    for (int i {1}, j {5}; i < 6 && j < 10; i++, j++)
    {
        std::cout  << i << "*" << j << "="<< i * j << std::endl;   // Sum: 15
    }

    cout << endl;

    //Перебор значений в стиле for-each////////////////////////////////////////////////////////////////////////////////////

    /*
    Существует также особая форма цикла for, которая предназначена специально для работы с последовательностями значений. 
    Эта форма имеет следующее формальное определение:

    for(тип переменная : последовательность)
    {
        инструкции;
    }
    */

    for (int n : {2, 3, 4, 5})
    {
        std::cout << n << std::endl;
    }

    cout << endl;

    for (char c : "Hello")
    {
        std::cout << c << std::endl;
    }

    cout << endl;

    //Цикл do/////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    В цикле do сначала выполняется код цикла, а потом происходит проверка условия в инструкции while.
    И пока это условие истинно, то есть не равно 0, то цикл повторяется. Формальное определение цикла:

    do
    {
        инструкции
    }
    while(условие);
    */

    i = 6;
    do
    {
        std::cout << i << std::endl;
        i--;
    }
    while(i>0);

    cout << endl;

    /*
    Но важно отметить, что цикл do гарантирует хотя бы однократное выполнение действий, даже если условие в инструкции while не будет истинно.
    То есть мы можем написать:

    i = -1;
    do
    {
        std::cout << i << std::endl;
        i--;
    }
    while(i>0);

    Хотя у нас переменная i меньше 0, цикл все равно один раз выполнится.
    */

    i = -1;
    do
    {
        std::cout << i << std::endl;
        i--;
    }
    while(i>0);

    cout << endl;

    //Среднее арифметическое чисел

    char reply {};          // ответ пользователя
    int count {};           // количество введенных чисел
    double number {};       // для ввода числа
    double total {};        // общая сумма чисел
    do
    {
        std::cout << "Enter a number: ";
        std::cin >> number; // Вводим число
        total += number;    // прибавляем к совокупному числу
        ++count;            // увеличиваем количество введенных чисел на 1
        std::cout << "Finish? (y/n): ";
        std::cin >> reply;  // считываем ответ пользователя
    } while (reply != 'y' && reply != 'Y');     // пока пользователь не введет символ y и Y
     
    std::cout << "The average value is " << total/count << std::endl;

    //Вложенные циклы for

    for (int i {1}; i < 10; i++)
    {
        for(int j {1}; j < 10; j++)
        {
            std::cout << i * j << "\t";
        }
        std::cout << std::endl;
    }

    cout << endl;

    //Операторы continue и break//////////////////////////////////////////////////////////////////////////////////////////

    /*
    Иногда возникает необходимость выйти из цикла до его завершения. В этом случае можно воспользоваться оператором break.
    Например, нам надо подсчитать сумму чисел от 1 до 9, пока она не станет больше 20:
    */

    int result{};
    for(int i{1}; i < 10; i++)
    {   
        result += i;
        std::cout << result << std::endl;
        if(result > 20) break;
    }

    cout << endl;

    /*
    В отличие от оператора break, оператор continue производит переход к следующей итерации.
    Например, нам надо посчитать сумму только нечетных чисел из некоторого диапазона:
    */

    result = 0;
    for (int i {1}; i<10; i++)
    {
        if (i % 2 == 0) continue;
        result +=i;
    }
    std::cout << "result = " << result << std::endl; // result = 25

    cout << endl;

    //Бесоконечные циклы//////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Для создания бесконечного цикла можно использовать любой вид циклов, но во всех случаях условие всегда истинно:

    // бесконечный цикл for - условие завершения отсутствует
    for (;;)
    {
    }
    // бесконечный цикл while - условие всегда равно true
    while (true)
    {
    }
    // бесконечный цикл do-while - условие всегда равно true
    do
    {
    }
    while (true);
    */

    /*
    Однако в этих случаях в зависимости от ситуации все равно может быть какое-то условие, при котором цикл может завершить работу.
    В этом случае для выхода из цикла может применяться оператор break.
    Например, пусть пользователь бесконечно может вводить числа, а программа выводит ему квадрат числа.
    Но если пользователь ввел 0, то выполним выход из цикла:
    */

    int n {};       // для ввода числа
    // бесконечный цикл
    while(true)
    {
        std::cout << "Enter a number: ";
        std::cin >> n; // Вводим число
        // если пользователь ввел 0, то выходим из цикла
        if(n == 0) break; 
        // иначе выводим квадрат числа
        std::cout << n * n << std::endl;   
    }

    cout << endl;
}

auto Links(){
    cout << "Links:" << endl;

    double number {123}; //123
    auto &refNumber = number;
    refNumber = 100;

    cout << "Number: " << number << endl;//100
    cout << "RefNumber: " << refNumber << endl;//100

    cout << sizeof(number) << endl;
    cout << sizeof(refNumber) << endl;

    auto &RefRefNumber = refNumber;
    RefRefNumber = 999.0f;

    cout << "Number: " << number << endl;//999
    cout << "RefRefNumber: " << RefRefNumber << endl;//999

    cout << sizeof(number) << endl;
    cout << sizeof(RefRefNumber) << endl;

    //Константные ссылки

    const int Value{5};
    const int &refValue{Value};
    std::cout << refValue << std::endl; // 5
    //refValue = 20;       изменять значение по ссылке нельзя

    int NoCONST {500};
    const auto &refCONST {NoCONST};

    cout << refCONST << endl;
    //refCONST = 230;       изменять значение нельзя

    //ссылки в цикле for///////////////////////////////////////////////////////////////////////////////////////////////////////////////

    int numbers[] {1, 2, 3, 4, 5};
    // теперь n - ссылка на элемент массива
    for (auto& n : numbers)
    {
        n = n * n;
        std::cout << n << "\t";
    }
    std::cout << std::endl;

    cout << endl;
}

const void Array(){
    cout << "Arrays:" << endl;

    const short n = 4;
    short numbers[n] {9,9,9,9};

    for(const auto& i : numbers){
        cout << i << '\t';
    }
    cout << endl;

    numbers[2] = 3; numbers[3] = 4;

    for(const auto& i : numbers){
        cout << i << '\t';
    }
    cout << endl;

    //////////////////////

    float ArrNum[] {1,2,3,4,5,6,7,8,9,0};
    auto& refArrNum = ArrNum;

    refArrNum[5] = 100;

    for(const auto& i : refArrNum){
        cout << i << '\t';
    }
    cout << endl;

    //Индексы. Получение и изменение элементов массива////////////////////////////////////////////////////////////////////////////////

    const int ArrValue[] {1,2,3,4,5,6,7,8,9,0};
    int FirstNum = ArrValue[0]; // 0
    //ArrValue[0] = 100; ошибка - значения элементов массива изменить нельзя

    //Длина массива/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    По сути длина массива равна совокупной длине его элементов. Все элементы представляют один и тот же тип и занимают один и тот же размер в памяти.
    Поэтому с помощью выражения sizeof(numbers) находим длину всего массива в байтах, а с помощью выражения sizeof(numbers[0]) - длину одного элемента в байтах.
    Разделив два значения, можно получить количество элементов в массиве.
    */

    int IntArrValue[] {1,2,3,4,5,6,7,8,9,0};
    int Length =  sizeof((IntArrValue)) / sizeof(IntArrValue[0]);

    cout << "Lenght = " << Length << endl;

    //Второй способ представляет применение встроенной библиотечной функции std::size():

    double DoubleArr[10] {10,11,12,13,14};
    int ArrSize = size(DoubleArr); // std::size()

    cout << "Lenght = " << Length << endl;

    //Перебор массивов/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    int ExArr[10] {11, 12, 13, 14};
    for(int i=0; i < size(ExArr); i++) std::cout << ExArr[i] << '\t';
    cout << endl;

    //Перебор элементов в стиле for-each///////////////////////////////////////////////////////////////////////////////////////////////

    short ShortArr[] {123, 234, 345, 456, 567, 678, 789};
    for(auto& i : ShortArr) cout << i << '\t';
    cout << endl;

    int Arr[] {111,222,333,444,555,666,777,888}; 
    for(int& i : Arr){
        i *= i;
        cout << i << '\t';
    }
    cout << endl;
    
    //Ввод значений массива с консоли/////////////////////////////////////////////////////////////////////////////////////////////////

    const int ARRAY_SIZE = 20;
    int IntArray[ARRAY_SIZE];

    for(int i = 0; i < ARRAY_SIZE; i++){
        cin >> IntArray[i];
    }

    for(int i : IntArray){
        cout << i << '\t';
    }
    cout << endl;

    cout << endl;
}

void MultidimensionalArrays(){
    cout << "Multidimensional Arrays:" << endl;

    //Каждый массив имеет такую характеристику как размерность. Количество размерностей соотвествует числу пар квадратных скобок. Например:

    int OneArr[5]{};
    int TwoArr[5][5] {};
    int ThreeArr[2][5][10] {};

    int MatrixArr[3][2] {
        {1,2},
        {3,4},
        {5,6}
    };

    int StrokeArr[3][8] { {1,2,3,4,5}, {6,7,8,9,10}, {11,12,13,14,15} };
    
    for(auto& subnum : StrokeArr){
        for(auto num : subnum){
            cout << num << '\t';
        }
        cout << endl;
    }
    cout << endl;

    int Arr3D[3][5][5] {
        {
            {1,2,3,4,5},
            {2,3,4,5,6},
            {3,4,5,6,7},
            {4,5,6,7,8},
            {5,6,7,8,9}
        },
        {
            {11,22,33,44,55},
            {22,33,44,55,66},
            {33,44,55,66,77},
            {44,55,66,77,88},
            {55,66,77,88,99}
        },
        {
            {111,222,333,444,555},
            {222,333,444,555,666},
            {333,444,555,666,777},
            {444,555,666,777,888},
            {555,666,777,888,999}
        }
    };

    for(auto& refArr1D : Arr3D){
        for(auto& refArr2D : refArr1D){
            for(auto& refArr3D : refArr2D){
                cout << refArr3D << "-";
            }
            cout << refArr2D << " // ";
        }
        cout << refArr1D << endl;
    }
    cout << endl;

    cout << endl;
}

void SymbolArray(){
    cout << "Symbol Arrays:" << endl;

    char hello1[] {'h', 'e', 'l', 'l', 'o'};
    char hello2[] {'1','2','3'};    // {'h', 'e', 'l', 'l', 'o', '0'}

    /*
    На первый взгляд оба массива имеют один и тот же набор символов, пусть в первом случае это просто набор отдельных символов, а во втором - строка.
    Но в первом случае - массив hello1 будет иметь пять элементов. А во втором случае массив hello2 будет иметь не 5 элементов, а 6,
    поскольку при инициализации строкой в символьный массив автоматически добавляется нулевой символ '\0'.
    */

    /*
    Способ определения символьного массива влияет на работу с ним. Так, при выводе на консоль оператор count отобразит всю строку до символа "\0".
    В конце обязательно должен быть символ '\0', иначе на консоль будут выводится символы из последовательных ячеек памяти, которые содержат мусор,
    пока не встретится либо нулевой символ, либо не произойдет недопустимый доступ к памяти. Например, сравним вывод трех символьных массивов:
    */

    char hello3[]{'h', 'e', 'l', 'l', 'o'}; /*
    В данном случае массив не содержит обязательного символа '\0' и вывод массива осуществляется до поиска этого символа в последующих ячейках памяти.
    По итогу спец символ нашёлся в ячейке памяти переменной 'hello2' и вывод - это слияние двух ячеек памяти.
    */

    char hello4[]{'h', 'e', 'l', 'l', 'o', '\0'};//Тут явео существует спец символ
    char hello5[]{"hello"};//Такой тип определения сивольного массива заранее включает в себя +1 символ от размера массива - это спец символ.
     
    std::cout << hello3 << std::endl;
    std::cout << hello4 << std::endl;
    std::cout << hello5 << std::endl;

    //Двухмерные массивы символов/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Здесь массив langs содержит 8 элементов (8 строк). Максимальное количество символов (условно стобцов) в каждой строке задается с помощью константы max_length.
    Но непосредственно сами строки массива необязательно должны достигать этой длины.
    Например, в строке "C++" только четыре символа (3 + автоматически добавляемый нулевой символ). Все остальные элементы получают по умолчанию нулевые значения.
    */

    const int MAX_LENGTH{50}; // максимальная длина строки (включая нулевой байт \0)
    char langs[][MAX_LENGTH] 
    {
        "C++", "C#",  "Python", "Java",
        "Kotlin", "Go", "Dart", "PHP"
    };
    std::cout << langs[0] << std::endl;     // C++
    std::cout << langs[1] << std::endl;     // C#
    std::cout << langs[2] << std::endl;     // Python
    cout << endl;

    //Перебор двухмерных символьных массивов/////////////////////////////////////////////////////////////////////////////////////////////////////////

    char strings[][20] { "C++", "Python", "JavaScript"};
    for(auto lang : strings)
    {
        std::cout << lang << std::endl;
    }
    cout << endl;

    //Ввод символьных массивов/строк с консоли///////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Функция getline() потока cin считывает последовательность символов, включая пробелы.
    По умолчанию, ввод заканчивается, когда считывается символ перевода строки '\n' (например, при нажатии клавиши Enter).
    Функция getline() имеет две версии. Первая версия принимает два параметра: первый параметра указывает на массив символов для хранения введенных данных,
    а второй параметр указывает на максимальное количество символов, которое надо сохранить в массив.
    Это количество включает символ завершения строки - нулевой байт '\0', который автоматически добавляться в конец ввода:
    */

    const int MAX_LENGTH_ARR = 100;    // максимальное количиство считываемых символов
    char text[MAX_LENGTH_ARR] {};       // массив для считывания строки
    std::cout << "Enter some text:" << std::endl;
    // считываем символы, включая пробелы
    std::cin.getline(text, MAX_LENGTH_ARR); //cin считывает последовательность символов, включая пробелы.
    std::cout << "You entered:\n" << text << std::endl;

    //Другая форма функции getline() также принимает третий параметр - символ, который будет выступать сиигналом завершения ввода. Например:

    const int MAX_LENGTH_ARR2 = 100;    // максимальное количиство считываемых символов
    char text2[MAX_LENGTH_ARR2] {};       // массив для считывания строки
    std::cout << "Enter some text:" << std::endl;
    // считываем символы, включая пробелы
    std::cin.getline(text2, MAX_LENGTH_ARR2, '!'); //Здесь в качестве символа окончания ввода выступает восклицательный знак !
    std::cout << "You entered:\n" << text2 << std::endl;

    cout << endl;
}

void IntroductionToStrings(){
    cout << "Introduction To Strings:" << endl;

    /*
    Мы можем работать со строками в С++ в так называемом С-стиле как с массивами символов, которые оканчиваются на нулевой байт '0'.
    Однако, что если такой символ не будет найден или в процессе манипуляций со строкой будет удален,
    то дальшейшие действия с такой строкой могут иметь недетерминированный результат.
    По этой причине строки в С-стиле считаются небезопасными, и рекомендуется для хранения строк в C++ использовать тип std::string из модуля <string>.

    Объект типа string содержит последовательность символов типа char, которая может быть пустой. Например, определение пустой строки:
    std::string message;
    */

    string message1 = "hello";
    string message2 ("hello");
    string message3 {"hello"};
    string message4;
    string message5 {message1};
    cout << message5 << endl;

    //Получение и изменение символов строки///////////////////////////////////////////////////////////////////////////////////////////////////////////

    //Подобно массиву мы можем обращаться с помощью индексов к отдельным символам строки, получать и изменять их:

    std::string hello {"Hello"};
    char c {hello[1]};      // e
    hello[0]='M';
    std::cout << hello << std::endl;    // Mello
    
    //Поскольку объект string представляет последовательность символов, то эту последовательность можно перебрать с помощью цикла for.
    //Например, подсчитаем, сколько раз в строке встречается буква "l":

    unsigned count{};   // счетчик, сколько раз встречается символ
    std::string message{ "Hello World"};
    for(const char c: message)
    {
        if(c == 'l')
        {
            count++;
        }
    }
    std::cout << "Count: " << count << std::endl;   // Count: 3

    //Чтение строки с консоли////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //Для считывания введенной строки с консоли, как и для считывания других значений, можно использовать объект std::cin:
    //Однако если при данном способе ввода строка будет содержать подстроки, разделенные пробелом, то std::cin будет использовать только первую подстроку:

    std::string name;
    std::cout << "Input your name: ";
    //std::cin >> name;
    std::cout << "Your name: " << name << std::endl;

    //Чтобы считать всю строку, применяется метод getline():

    name.clear();
    std::cout << "Input your name: " << endl;
    getline(cin, name,'!'); //Ввод строки до символа !
    std::cout << "Your name: " << name << std::endl;

    cout << endl;
}

int main()
{
    //g++ -std=c++20 -Wall -pedantic Chapter_1.cpp -o chapter_1; ./chapter_1

    //OutputInConsole(); //Вывод в консоль
    // DataTypes(); //Типы данных
    // Constants(); //Константы
    // InputOutput(); //Ввод-Вывод в консоли
    // NamespaceUsing(); //using. Подключение пространств имен и определение псевдонимов
    // ArithmeticOperations(); //Арифметические операции
    // StaticTypingAndTypeConversions(); //Статическая типизация и преобразования типов
    // AssignmentOperators(); // Операции присваивания
    // ConditionalExpressions(); // Условные выражения
    // IfElseConstruct_TernaryOperator(); //Конструкция if-else и тернарный оператор
    // SwitchCaseConstruction(); //Конструкция switch-case
    // Cycles(); //Циклы
    // Links(); //Ссылки
    // Array(); //Массивы
    //MultidimensionalArrays(); //Многомерные массивы
    //SymbolArray(); //Символьные массивы
    //IntroductionToStrings(); //Введение в строки
    return 0;
} 